migration : general approach 

  being reflection based instead of subclassing and annotating, there is a big migration path from or to ticino.
  Lets demonstrate the migration in case of wicket - which runs nearly out-of-the-box:
  
+--------------------------------
public class WicketApplication extends WebApplication {

  @Override
  public void onEvent(IEvent<MyPayLoad> event) {
	// keep the wicket way functioning
	super.onEvent(event);
	
	// but also support strict typed ticino event handling
	Ticino.dispatch (event.getPayload()) ;
  }
}
+--------------------------------
   
   Somewhere else...
   
+--------------------------------
public class NoSink {
   
   public NoSink () {
     Ticino.register (MyPayLoad.class , this) ; 
   }
   
   public void blablah (MyPayLoad payload) {
     // doSomething meaningful
   }
   
}
+--------------------------------

    Note that you dont have to unregister - ticino does this for you if the receiver gets gc'ed.   
  
Spring integration - static aproach
   
   To integrate ticino with spring, use the following dependency : 
   
   
   
+--------------------------------
<dependencies>
  <dependency>
    <groupId>${project.groupId}</groupId>
	  <artifactId>ticino-spring</artifactId>
	  <version>${project.version}</version>
  </dependency>
</dependencies>
+--------------------------------

   You can remove the dependency to ticino-core, this comes along with ticino-spring.
   
   Then, configure your listeners similar to the following snippet in the spring context:

+--------------------------------
	<!-- create the configurator as bean -->
	<bean class="net.micwin.ticino.spring.Configurator">
		<constructor-arg>
			<map>
				<entry>
					<!-- the event class to register to -->
					<key>
						<value>net.micwin.ticino.test.spring.SpringEvent1</value>
					</key>
					
					<!-- a list of listener beans to this event. -->
					<list>
						<ref bean="listener1" />
					</list>
				</entry>
				<entry>
					<key>
						<value>net.micwin.ticino.test.spring.SpringEvent2</value>
					</key>
					
					<!-- you also can register multiple listeners to one event class -->
					<list>
						<ref bean="listener2" />
						<ref bean="listener3" />
						
						<!-- provided listener1 has an appropriate receiver method, you of course can reuse it as well -->
						<ref bean="listener1" />
					</list>
				</entry>
			</map>
		</constructor-arg>
	</bean>

+--------------------------------

Spring integration - default bean aproach
    
    In the spring context, create a event scope bean
    
+--------------------------------
    <bean class="net.micwin.ticino.EventScope" />
+--------------------------------

    Autowire that in a receiver

+--------------------------------
public class Receiver {
    
    @Autowired
    EventScope eventScope ;
    
    private void init () {
        eventScope.register (Payload.class, this) ;
    }
    
    public void receive (Payload payload) {
        // do something meaningful with the received event
    }
}   
+--------------------------------
    
    and in a caller
    
+--------------------------------
public class Caller {
    
    @Autowired
    EventScope eventScope ;
    
    public void doSomething (Payload payload) {
        eventScope.dispatch (payload) ;
    }
}
+--------------------------------    

    Some Notes here
    
    * of course you can use multiple event scopes at once. They will have a disjunct set of event registrations, that is, receivers.
    
    * this approach does not interfere with the static aproach above; so you could use the static aproach for common/global events
    and use private event scopes for more security related things not every class should be able to register to.

event inheritance

    say we have a general event containing logic and data common to all of your events, ...
    
+--------------------------------
class GeneralEvent {
	// some general stuff
}
+--------------------------------

	... an event containing data for a specific use case and extending GeneralEvent, ...

+--------------------------------
class SpecificEvent extends GeneralEvent {
	// some use case specific data
}
+--------------------------------

    ... a receiver triggered by the general event, ...
    
+--------------------------------
class Receiver {
    public void receive(GeneralEvent event) {
        System.out.println("got event of " + event.getClass());
    }
}
+--------------------------------

    ... some main method bringing event and receiver together (normally you would do that in a spring context) ...
    
+--------------------------------
public static void main(String[] args) {
    Ticino.register(GeneralEvent.class, new Receiver());
}
+--------------------------------

    ... then you could dispatch a specific event like that ...
    
+--------------------------------
// fire specific event
    Specific event evt = new SpecificEvent();
    Ticino.dispatch(evt);
+--------------------------------

    ... and finally get an output like that :

+--------------------------------    
got event of class net.micwin.examples.inheritance.Main$SpecificEvent
+--------------------------------