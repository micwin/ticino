migration : general approach 

  being reflection based instead of subclassing and annotating, there is a big migration path from or to ticino.
  Lets demonstrate the migration in case of wicket - which runs nearly out-of-the-box:
  
+--------------------------------
public class WicketApplication extends WebApplication {

  @Override
  public void onEvent(IEvent<MyPayLoad> event) {
	// keep the wicket way functioning
	super.onEvent(event);
	
	// but also support strict typed ticino event handling
	Ticino.dispatch (event.getPayload()) ;
  }
}
+--------------------------------
   
   Somewhere else...
   
+--------------------------------
public class NoSink {
   
   public NoSink () {
     Ticino.register (MyPayLoad.class , this) ; 
   }
   
   public void blablah (MyPayLoad payload) {
     // doSomething meaningful
   }
   
}

+--------------------------------

    Note that you dont have to unregister - ticino does this for you if the receiver gets gc'ed.   
  
Spring integration
   
   To integrate ticino with spring, use the following dependency : 
   
   
   
+--------------------------------
<dependencies>
  <dependency>
    <groupId>${project.groupId}</groupId>
	  <artifactId>ticino-spring</artifactId>
	  <version>${project.version}</version>
  </dependency>
</dependencies>
+--------------------------------

   You can remove the dependency to ticino-core, this comes along with ticino-spring.
   
   Then, configure your listeners similar to the following snippet in the spring context:

+--------------------------------

	<!-- create the configurator as bean -->
	<bean class="net.micwin.ticino.spring.Configurator">
		<constructor-arg>
			<map>
				<entry>
					<!-- the event class to register to -->
					<key>
						<value>net.micwin.ticino.test.spring.SpringEvent1</value>
					</key>
					
					<!-- a list of listener beans to this event. -->
					<list>
						<ref bean="listener1" />
					</list>
				</entry>
				<entry>
					<key>
						<value>net.micwin.ticino.test.spring.SpringEvent2</value>
					</key>
					
					<!-- you also can register multiple listeners to one event class -->
					<list>
						<ref bean="listener2" />
						<ref bean="listener3" />
						
						<!-- provided listener1 has an appropriate receiver method, you of course can reuse it as well -->
						<ref bean="listener1" />
					</list>
				</entry>
			</map>
		</constructor-arg>
	</bean>

+--------------------------------

event inheritance

    say we have a general event containing logic and data common to all of your events, ...
    
+--------------------------------
class GeneralEvent {
	// some general stuff
}
+--------------------------------

	... an event containing data for a specific use case and extending GeneralEvent, ...

+--------------------------------
class SpecificEvent extends GeneralEvent {
	// some use case specific data
}
+--------------------------------

    ... a receiver triggering to the general event, ...
    
+--------------------------------
class Receiver {
    public void receive(GeneralEvent event) {
        System.out.println("got event of " + event.getClass());
    }
}
+--------------------------------

    ... some main method bringing event and receiver together (normally you would do that with spring) ...
    
+--------------------------------
public static void main(String[] args) {
    Ticino.register(GeneralEvent.class, new Receiver());
}
+--------------------------------

    ... then you could dispatch a specific event like that ...
    
+--------------------------------
// fire specific event
    Specific event evt = new SpecificEvent();
    Ticino.dispatch(evt);
+--------------------------------

    ... and finally get an output like that :

+--------------------------------    
got event of class net.micwin.examples.inheritance.Main$SpecificEvent
+--------------------------------
